"""
Anti-pattern regression tests for semfora-explorer analytics.

Each test:
  1. Verifies that the expected analytic signal IS present in the anti-pattern DB.
  2. Verifies that the signal is NOT triggered (or is below threshold) in the clean
     baseline DB — proving we're detecting the pattern, not reporting noise.

Fixture DBs are pre-generated by generate_dbs.sh and live in data/.
Tests skip automatically if the DB files are missing.
"""
import sqlite3
import pytest
from conftest import (
    get_conn,
    query_dead_code,
    query_cycles,
    query_module_coupling,
    query_module_symbol_counts,
    query_top_callers,
    count_modules_calling_node,
)


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def module_edges(conn: sqlite3.Connection) -> dict:
    """Return dict of (caller_module, callee_module) -> edge_count, external excluded."""
    rows = conn.execute(
        """SELECT caller_module, callee_module, edge_count FROM module_edges
           WHERE caller_module NOT LIKE '__ext%' AND callee_module NOT LIKE '__ext%'"""
    ).fetchall()
    return {(r["caller_module"], r["callee_module"]): r["edge_count"] for r in rows}


def caller_count_for(conn: sqlite3.Connection, name: str, module: str) -> int:
    row = conn.execute(
        "SELECT caller_count FROM nodes WHERE name=? AND module=?", (name, module)
    ).fetchone()
    return row["caller_count"] if row else 0


def symbol_count_for_module(conn: sqlite3.Connection, module: str) -> int:
    row = conn.execute(
        "SELECT COUNT(*) as n FROM nodes WHERE module=? AND hash NOT LIKE 'ext:%'",
        (module,)
    ).fetchone()
    return row["n"] if row else 0


def modules_calling_into(conn: sqlite3.Connection, target_module: str) -> set:
    """Return set of distinct modules that call into target_module (excluding self)."""
    rows = conn.execute(
        """SELECT DISTINCT n2.module FROM edges e
           JOIN nodes n  ON e.callee_hash = n.hash
           JOIN nodes n2 ON e.caller_hash = n2.hash
           WHERE n.module = ? AND n2.module != ?
             AND n2.module NOT LIKE '__ext%'""",
        (target_module, target_module)
    ).fetchall()
    return {r["module"] for r in rows}


# ---------------------------------------------------------------------------
# 1. God Object
# ---------------------------------------------------------------------------

class TestGodObject:
    """
    A god object (god/task_manager.py) absorbs cross-cutting concerns.
    Signal: a new 'god' module appears; services module loses all direct callers.
    """

    def test_god_module_exists(self):
        conn = get_conn("taskboard-antipattern-god-object@HEAD.db")
        row = conn.execute(
            "SELECT COUNT(*) as n FROM nodes WHERE module='god' AND hash NOT LIKE 'ext:%'"
        ).fetchone()
        assert row["n"] >= 20, (
            f"Expected >=20 symbols in 'god' module, got {row['n']}. "
            "God object should dominate the symbol count."
        )

    def test_services_bypassed(self):
        """Nobody calls services directly any more — all traffic routes through the god object."""
        conn = get_conn("taskboard-antipattern-god-object@HEAD.db")
        coup = query_module_coupling(conn)
        services_ca = coup.get("services", {}).get("afferent", 0)
        assert services_ca == 0, (
            f"Expected services afferent coupling = 0 (bypassed by god object), got {services_ca}."
        )

    def test_baseline_has_no_god_module(self):
        """Confirm the clean baseline has no 'god' module — this is not a false positive."""
        conn = get_conn("taskboard-main@HEAD.db")
        row = conn.execute(
            "SELECT COUNT(*) as n FROM nodes WHERE module='god'"
        ).fetchone()
        assert row["n"] == 0, "Clean baseline should have no 'god' module."

    def test_baseline_services_has_callers(self):
        """In the clean baseline, services is properly called by other modules."""
        conn = get_conn("taskboard-main@HEAD.db")
        coup = query_module_coupling(conn)
        services_ca = coup.get("services", {}).get("afferent", 0)
        assert services_ca >= 5, (
            f"Expected clean baseline services Ca>=5, got {services_ca}."
        )


# ---------------------------------------------------------------------------
# 2. Circular Dependencies
# ---------------------------------------------------------------------------

class TestCircularDeps:
    """
    Domain calls into services (backward direction), creating a cross-module cycle.
    Signal: bidirectional module edge between 'domain' and 'services'.
    """

    def test_cross_module_bidirectional_edge(self):
        """domain -> services AND services -> domain should both exist."""
        conn = get_conn("taskboard-antipattern-circular-deps@HEAD.db")
        edges = module_edges(conn)
        domain_to_services = edges.get(("domain", "services"), 0)
        services_to_domain = edges.get(("services", "domain"), 0)
        assert domain_to_services >= 3, (
            f"Expected domain->services edge count >=3, got {domain_to_services}. "
            "Domain methods calling back into services should be detected."
        )
        assert services_to_domain >= 10, (
            f"Expected services->domain edge count >=10, got {services_to_domain}."
        )

    def test_domain_calls_services_specific_functions(self):
        """The domain module must directly call notification functions in services."""
        conn = get_conn("taskboard-antipattern-circular-deps@HEAD.db")
        rows = conn.execute(
            """SELECT DISTINCT cn.name, ee.name AS callee_name
               FROM edges e
               JOIN nodes cn ON e.caller_hash = cn.hash
               JOIN nodes ee ON e.callee_hash = ee.hash
               WHERE cn.module = 'domain' AND ee.module = 'services'"""
        ).fetchall()
        domain_to_service_calls = {r["callee_name"] for r in rows}
        # At least one notification call should be wired into domain methods
        assert len(domain_to_service_calls) >= 3, (
            f"Expected >=3 distinct service functions called from domain, "
            f"got {len(domain_to_service_calls)}: {domain_to_service_calls}"
        )

    def test_baseline_no_domain_to_services(self):
        """Clean baseline must have no domain -> services calls (one-way dependency only)."""
        conn = get_conn("taskboard-main@HEAD.db")
        edges = module_edges(conn)
        domain_to_services = edges.get(("domain", "services"), 0)
        assert domain_to_services == 0, (
            f"Baseline should have no domain->services edge, got {domain_to_services}. "
            "If this fails, the baseline itself has circular deps."
        )


# ---------------------------------------------------------------------------
# 3. Dead Code Graveyard
# ---------------------------------------------------------------------------

class TestDeadCodeGraveyard:
    """
    A legacy/ module full of unreachable functions + dead code piled up in services and utils.
    Signal: dead ratio significantly higher than baseline; legacy module entirely dead.
    """

    def test_dead_ratio_higher_than_baseline(self):
        conn_ap = get_conn("taskboard-antipattern-dead-code-graveyard@HEAD.db")
        conn_bl = get_conn("taskboard-main@HEAD.db")
        ap = query_dead_code(conn_ap)
        bl = query_dead_code(conn_bl)
        assert ap["dead_ratio"] >= bl["dead_ratio"] + 0.05, (
            f"Anti-pattern dead ratio {ap['dead_ratio']:.3f} should be "
            f">=5pp above baseline {bl['dead_ratio']:.3f}."
        )

    def test_legacy_module_is_all_dead(self):
        """Every function in the legacy module should be unreachable."""
        conn = get_conn("taskboard-antipattern-dead-code-graveyard@HEAD.db")
        dc = query_dead_code(conn)
        legacy_dead = [n for n in dc["nodes"] if n.get("module") == "legacy"]
        assert len(legacy_dead) >= 8, (
            f"Expected >=8 dead symbols in 'legacy' module, got {len(legacy_dead)}."
        )

    def test_legacy_module_absent_from_baseline(self):
        conn = get_conn("taskboard-main@HEAD.db")
        row = conn.execute(
            "SELECT COUNT(*) as n FROM nodes WHERE module='legacy'"
        ).fetchone()
        assert row["n"] == 0, "Clean baseline should have no 'legacy' module."

    def test_signal_not_noise(self):
        """
        The safe-confidence dead count should substantially exceed the caution count,
        proving we're finding real dead code rather than just flagging entrypoints.
        """
        conn = get_conn("taskboard-antipattern-dead-code-graveyard@HEAD.db")
        dc = query_dead_code(conn)
        assert dc["safe_count"] > dc["caution_count"] * 3, (
            f"Expected safe >> caution*3 to confirm low false-positive rate. "
            f"safe={dc['safe_count']} caution={dc['caution_count']}"
        )


# ---------------------------------------------------------------------------
# 4. Util Dumping Ground
# ---------------------------------------------------------------------------

class TestUtilDumpingGround:
    """
    A bloated utils/helpers.py used as a catch-all by every module.
    Signal: utils afferent coupling (fan-in) explodes vs baseline.
    """

    AFFERENT_THRESHOLD = 35        # anti-pattern: Ca ~49
    BASELINE_AFFERENT_MAX = 15     # baseline: Ca ~6

    def test_utils_high_afferent_coupling(self):
        conn = get_conn("taskboard-antipattern-util-dumping-ground@HEAD.db")
        coup = query_module_coupling(conn)
        utils_ca = coup.get("utils", {}).get("afferent", 0)
        assert utils_ca >= self.AFFERENT_THRESHOLD, (
            f"Expected utils afferent coupling >= {self.AFFERENT_THRESHOLD}, got {utils_ca}. "
            "Util dumping ground should be heavily depended upon."
        )

    def test_utils_called_from_many_modules(self):
        conn = get_conn("taskboard-antipattern-util-dumping-ground@HEAD.db")
        callers = modules_calling_into(conn, "utils")
        assert len(callers) >= 3, (
            f"Expected utils to be called from >=3 distinct modules, got {len(callers)}: {callers}."
        )

    def test_utils_symbol_count_inflated(self):
        conn = get_conn("taskboard-antipattern-util-dumping-ground@HEAD.db")
        utils_count = symbol_count_for_module(conn, "utils")
        assert utils_count >= 35, (
            f"Expected >=35 symbols in utils (dumping ground), got {utils_count}."
        )

    def test_baseline_utils_low_afferent(self):
        conn = get_conn("taskboard-main@HEAD.db")
        coup = query_module_coupling(conn)
        utils_ca = coup.get("utils", {}).get("afferent", 0)
        assert utils_ca <= self.BASELINE_AFFERENT_MAX, (
            f"Baseline utils Ca should be <={self.BASELINE_AFFERENT_MAX}, got {utils_ca}. "
            "If this fails, baseline has a util dumping ground."
        )


# ---------------------------------------------------------------------------
# 5. Tight Coupling (API → Storage bypass)
# ---------------------------------------------------------------------------

class TestTightCoupling:
    """
    API handlers reach directly into storage, skipping the service layer entirely.
    Signal: api->storage direct edge with high call count; services afferent drops.
    """

    def test_direct_api_to_storage_edge(self):
        conn = get_conn("taskboard-antipattern-tight-coupling@HEAD.db")
        edges = module_edges(conn)
        api_to_storage = edges.get(("api", "storage"), 0)
        assert api_to_storage >= 20, (
            f"Expected api->storage edge count >=20, got {api_to_storage}. "
            "Tight coupling should produce many direct api->storage calls."
        )

    def test_services_layer_bypassed(self):
        """Services afferent should be very low — callers are talking to storage directly."""
        conn = get_conn("taskboard-antipattern-tight-coupling@HEAD.db")
        coup = query_module_coupling(conn)
        services_ca = coup.get("services", {}).get("afferent", 0)
        assert services_ca <= 10, (
            f"Expected services Ca<=10 (bypassed), got {services_ca}."
        )

    def test_baseline_no_direct_api_storage(self):
        """Clean baseline routes through services — no direct api->storage edge."""
        conn = get_conn("taskboard-main@HEAD.db")
        edges = module_edges(conn)
        api_to_storage = edges.get(("api", "storage"), 0)
        assert api_to_storage == 0, (
            f"Baseline should have no api->storage edge, got {api_to_storage}. "
            "Clean architecture keeps api away from storage."
        )

    def test_baseline_services_properly_used(self):
        conn = get_conn("taskboard-main@HEAD.db")
        coup = query_module_coupling(conn)
        services_ca = coup.get("services", {}).get("afferent", 0)
        assert services_ca >= 8, (
            f"Baseline services Ca should be >=8 (properly used), got {services_ca}."
        )


# ---------------------------------------------------------------------------
# 6. Unstable Foundation
# ---------------------------------------------------------------------------

class TestUnstableFoundation:
    """
    Domain model is load-bearing (high afferent) but also has high efferent —
    it depends on storage AND is depended on by everyone. Changes ripple in both directions.
    Signal: domain efferent grows significantly vs baseline while afferent also grows.
    """

    def test_domain_high_afferent_and_efferent(self):
        """
        Domain must be load-bearing (high Ca) AND have outgoing internal deps (Ce > 0).
        Note: Ce is intentionally low here — that's the point. In clean architecture
        domain has Ca but NO Ce (pure value objects). The anti-pattern introduces Ce > 0,
        meaning domain now calls back into other layers.
        """
        conn = get_conn("taskboard-antipattern-unstable-foundation@HEAD.db")
        coup = query_module_coupling(conn)
        domain = coup.get("domain", {})
        assert domain.get("afferent", 0) >= 70, (
            f"Expected domain Ca>=70 (many callers = load-bearing), "
            f"got {domain.get('afferent', 0)}."
        )
        assert domain.get("efferent", 0) >= 5, (
            f"Expected domain Ce>=5 (domain calling out to other modules = unstable), "
            f"got {domain.get('efferent', 0)}. "
            "In clean architecture, domain has zero outgoing internal deps."
        )

    def test_domain_efferent_grew_vs_baseline(self):
        """
        Baseline domain has zero internal efferent coupling (pure value objects).
        Anti-pattern introduces outgoing calls — any Ce > 0 is the signal.
        """
        conn_ap = get_conn("taskboard-antipattern-unstable-foundation@HEAD.db")
        conn_bl = get_conn("taskboard-main@HEAD.db")
        ap_ce = query_module_coupling(conn_ap).get("domain", {}).get("efferent", 0)
        bl_ce = query_module_coupling(conn_bl).get("domain", {}).get("efferent", 0)
        assert bl_ce == 0, (
            f"Baseline domain Ce should be 0 (pure value objects), got {bl_ce}."
        )
        assert ap_ce >= 5, (
            f"Anti-pattern domain Ce={ap_ce} should be >=5. "
            "Domain calling into other internal modules is the unstable foundation signal."
        )

    def test_domain_afferent_grew_vs_baseline(self):
        """Domain also became MORE load-bearing (more things depend on it)."""
        conn_ap = get_conn("taskboard-antipattern-unstable-foundation@HEAD.db")
        conn_bl = get_conn("taskboard-main@HEAD.db")
        ap_ca = query_module_coupling(conn_ap).get("domain", {}).get("afferent", 0)
        bl_ca = query_module_coupling(conn_bl).get("domain", {}).get("afferent", 0)
        assert ap_ca >= bl_ca + 10, (
            f"Anti-pattern domain Ca={ap_ca} should be >=10 more than baseline Ca={bl_ca}."
        )

    def test_storage_coupling_shifted_to_domain(self):
        """
        Top caller_count nodes should include domain nodes, not just storage.
        In baseline, storage.save is the most-called; in anti-pattern, domain absorbs that role.
        """
        conn = get_conn("taskboard-antipattern-unstable-foundation@HEAD.db")
        top = query_top_callers(conn, top_n=5)
        top_modules = [n["module"] for n in top]
        assert "domain" in top_modules, (
            f"Expected 'domain' in top-5 most-called nodes, got: {top_modules}. "
            "Domain should be acting as a pseudo-foundation in the unstable pattern."
        )


# ---------------------------------------------------------------------------
# 7. Feature Creep
# ---------------------------------------------------------------------------

class TestFeatureCreep:
    """
    A massive project_hub.py bolted onto the api module, importing from every layer.
    Signal: api symbol count explodes; a single function (require_auth) becomes a
    dependency hub with dramatically inflated caller_count.
    """

    API_SYMBOL_THRESHOLD = 55          # anti-pattern api: 68 symbols
    BASELINE_API_SYMBOL_MAX = 35       # baseline api: 31 symbols
    REQUIRE_AUTH_CALLER_THRESHOLD = 45 # anti-pattern: 55 callers

    def test_api_module_bloated(self):
        conn = get_conn("taskboard-antipattern-feature-creep@HEAD.db")
        api_count = symbol_count_for_module(conn, "api")
        assert api_count >= self.API_SYMBOL_THRESHOLD, (
            f"Expected >=/{self.API_SYMBOL_THRESHOLD} symbols in api module (feature creep), "
            f"got {api_count}."
        )

    def test_api_largest_module(self):
        """After feature creep, api should be the biggest module by symbol count."""
        conn = get_conn("taskboard-antipattern-feature-creep@HEAD.db")
        counts = query_module_symbol_counts(conn)
        meaningful = {k: v for k, v in counts.items() if not k.startswith("_") and k not in ("generate_dbs", "taskboard")}
        largest = max(meaningful, key=meaningful.get)
        assert largest == "api", (
            f"Expected 'api' to be the largest module after feature creep, got '{largest}'. "
            f"Counts: {meaningful}"
        )

    def test_require_auth_caller_explosion(self):
        """require_auth becomes the de-facto hub of the bloated api module."""
        conn = get_conn("taskboard-antipattern-feature-creep@HEAD.db")
        ca = caller_count_for(conn, "require_auth", "api")
        assert ca >= self.REQUIRE_AUTH_CALLER_THRESHOLD, (
            f"Expected require_auth caller_count >={self.REQUIRE_AUTH_CALLER_THRESHOLD}, got {ca}. "
            "Feature creep causes a single auth function to be called by all new endpoints."
        )

    def test_baseline_api_not_bloated(self):
        conn = get_conn("taskboard-main@HEAD.db")
        api_count = symbol_count_for_module(conn, "api")
        assert api_count <= self.BASELINE_API_SYMBOL_MAX, (
            f"Baseline api module should have <={self.BASELINE_API_SYMBOL_MAX} symbols, "
            f"got {api_count}."
        )

    def test_baseline_require_auth_low_caller_count(self):
        conn = get_conn("taskboard-main@HEAD.db")
        ca = caller_count_for(conn, "require_auth", "api")
        assert ca <= 25, (
            f"Baseline require_auth should have <=25 callers, got {ca}. "
            "If it's already high, the baseline has its own feature creep problem."
        )
